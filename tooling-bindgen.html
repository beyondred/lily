<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Bindgen - Lily</title>

        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="css/bootstrap-theme.min.css" rel="stylesheet">

        <link href="css/docstyle.css" rel="stylesheet">

        <script src="js/ie-emulation-modes-warning.js"></script>
    </head>

    <body role="document">
<div class="container">
    <div class="row">
        <div class="col-md-3">
            <div class="sidebar-nav">
                <div class="well">
                    <ul class="nav">
<li class="nav-header">Intro</li>
<li><a href="index.html">Welcome</a></li>
<li><a href="intro-sandbox.html">Sandbox</a></li>
<li class="nav-header">Tutorial</li>
<li><a href="tutorial-install.html">Install</a></li>
<li><a href="tutorial-basics.html">Basics</a></li>
<li><a href="tutorial-functions.html">Functions</a></li>
<li><a href="tutorial-classes.html">Classes</a></li>
<li><a href="tutorial-exceptions.html">Exceptions</a></li>
<li><a href="tutorial-generics.html">Generics</a></li>
<li><a href="tutorial-enums.html">Enums</a></li>
<li><a href="tutorial-import.html">Import</a></li>
<li class="nav-header">Tools</li>
<li class="active"><a href="tooling-bindgen.html">Bindgen</a></li>
<li><a href="tooling-docgen.html">Docgen</a></li>
<li class="nav-header">Reference</li>
<li><a href="api/index.html">lily.h api</a></li>
<li><a href="core/module.core.html">Modules</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <p>Usage: <code>lily bindgen.lily &lt;some c file&gt;</code></p>
<p>Bindgen is a tool for helping extend the Lily interpreter with new classes,
enums, methods, and so on. This tool generates bindings for the interpreter to
load what you've made. Before you begin, you should be familiar with writing
Lily code, and also comfortable with C as well.</p>
<p>Bindgen is in the <code>FascinatedBox/lily-parsekit</code> repo at Github.</p>
<h2>Why this tool exists</h2>
<p>Most interpreters are extended by having the C library export a special function
that they will look for. That function then calls back into the interpreter to
add functions, classes, and so forth. For those, no binding tool is necessary.</p>
<p>Lily's loading mechanism is different, consisting of a string table holding
definitions, and a loading function. The loading function returns C function
pointer or, in the case of vars, provides the interpreter to the var loader so
the var loader can push relevant information back.</p>
<p>Since Lily is statically-typed, the overhead required for storing definitions,
classes, and enums is greater because of the typing involved. Furthermore, a
user is loading a large library, there is a chance that they may not need all of
what the library exports. In the reverse, where all elements of a library are
used, the cost of several table lookups should be negligible compared to the
time used processing the entire program.</p>
<p>The interpreter uses this lazy loading system (termed dynaload in much of Lily)
as a means of saving both memory and time by avoiding loading the over 70
functions in the builtin library unless the type system can prove they are
needed.</p>
<h2>How this tool works</h2>
<p>This tool works by reading in a source <code>.c</code> file. It will look for comments that
follow this form:</p>
<pre><code>/**
thing blah blah

information about the thing
*/
</code></pre>

<p>The tool treats 'thing' as a command. Everything from that until the first blank
line is data the command. What proceeds after the blank line is treated as
documentation for 'thing'. From these comments, the tool will build macros, a
table, and a loader for you.</p>
<p>The contents generated by the tool are placed in the autogen section of the
file. The autogen section of the file is denoted by the following:</p>
<pre><code>/** Begin autogen section. **/
/** End autogen section. **/
</code></pre>

<p>In terms of organization, the first command should be the <code>library</code> command that
specifies the name of what you're creating, and the library's documentation.
After that should be classes and enums. Finally, package-level vars and
functions should be last.</p>
<h2>Issues</h2>
<ul>
<li>Classes must be mentioned before their use.</li>
<li>Modules cannot export sub modules (may not happen).</li>
<li>The tool allows a 'static' qualifer, but the language does not (yet).</li>
<li>Foreign classes cannot be marked by the garbage collector.</li>
<li>Enums are undocumented since they don't work externally yet.</li>
</ul>
<h2>Commands</h2>
<p>The rest of this document focuses on commands that are available, what they
generate, and sometimes how to use it.</p>
<p>Some keywords create a scope. The <code>define</code> keyword will create definitions under
the current scope as long as the name has the scope as a qualifer. For example,
writing <code>File.print</code> instead of just <code>print</code>.</p>
<p>A scope is complete when another scope begins or when an unqualified define is
seen.</p>
<h3 id='library-<name>'>library <name></h3>
<p>This command specifies the name of the package. This is used later by <code>var</code> and
<code>define</code> for locating functions:</p>
<p>Given the library name <code>builtin</code>:</p>
<ul>
<li>
<p>Method <code>to_s</code> in <code>Integer</code>: <code>lily_builtin_to_s</code>.</p>
</li>
<li>
<p>Constructor for <code>Exception</code>: <code>lily_builtin_Exception_new</code>.</p>
</li>
<li>
<p>Toplevel function <code>calltrace</code>: <code>lily_builtin__calltrace</code>.</p>
</li>
<li>
<p>Toplevel var <code>stdout</code>: <code>lily_builtin_var_stdout</code>.</p>
</li>
<li>
<p>A teardown function for <code>File</code>: <code>destroy_File</code>.</p>
</li>
</ul>
<h3 id='native-class-<name>-<ctor>-(&lt;-parent)?-'{'-<properties>-...-'}''>native class <name> <ctor> (&lt; parent)? '{' <properties> ... '}'</h3>
<p>This introduces a native class to the interpreter. A native class can inherit
another native class, as well as be inherited. The <code>&lt;ctor&gt;</code> section is processed
as arguments that will need to be passed to invoke the <code>&lt;name&gt;(...)</code> class
constructor.</p>
<p>Normally, Lily will reject a definition that has an empty <code>()</code>. However, both
<code>native class</code> and <code>foreign class</code> allow for empty <code>()</code> for a constructor that
does not take arguments.</p>
<p>Make sure to not put a blank line in the property section, or the tool will
assume the contents following it are a documentation comment. Be aware that the
interpreter won't call underlying constructor functions either, as it assumes
the foreign constructor will do it.</p>
<p>An an example, here is the definition for <code>Exception</code>:</p>
<pre><code>native class Exception {
    var @message: String
    var @traceback: List[String]
}
</code></pre>

<p>Since neither property has a <code>protected</code> or <code>private</code> qualifier, both are
publically accessible. As for initialization, it works as follows:</p>
<pre><code>void lily_builtin_Exception_new(lily_state *s)
{
    lily_container_val *result = lily_push_super(s, id, 2);

    lily_con_set(result, 0, lily_arg_value(s, 0));

    lily_push_list(s, 0);
    lily_con_set_from_stack(s, result, 1);
    lily_return_super(s);
}
</code></pre>

<p>The function <code>lily_push_super</code> will check to see if an in-progress class has
been passed. It will return either that, or a newly-made instance. From there,
the message (0) and traceback (1) fields are set.</p>
<h3 id='foreign-class-<name>-<ctor>?-'{'-<layout>-'}''>foreign class <name> <ctor>? '{' <layout> '}'</h3>
<p>This introduces a foreign class to Lily. Foreign classes are implemented as a
wrapper class, to which you can add members that you wish. Here is an example
from the <code>postgres</code> wrapper library:</p>
<pre><code>/**
foreign class Conn {
    layout {
        uint64_t is_open;
        PGconn *conn;
    }
}

The `Conn` class represents a connection to a postgres server.
*/
</code></pre>

<p>The tool will generate a <code>lily_postgres_Conn</code> struct in the header section as
well as an init macro so that Lily can allocate memory for one of the structs.
One example of initializing the given struct:</p>
<pre><code>    PGconn *conn = PQsetdbLogin(...);

    if (PQstatus(conn) == CONNECTION_OK) {
        lily_postgres_Conn *c = INIT_Conn(state)
        c-&gt;is_open = 1;
        c-&gt;conn = conn;
        lily_return_top(state, (lily_foreign_val *)c);
    }
    else {
        /* error handling */
    }
</code></pre>

<p>The <code>INIT_&lt;class&gt;</code> macro generated expects a destroy function that must be
written. The destroy function can be run directly from a deref step of the
interpreter, or as a side-effect of garbage collection. The destroy function is
provided with a value, and is responsible for cleaning out what was not created
by the interpreter.</p>
<pre><code>void destroy_Conn(lily_postgres_Conn *conn_value)
{
    PQfinish(conn_value-&gt;conn);
}
</code></pre>

<p>The interpreter is written with the intention that value teardown does not
produce side-effects such as changing other values or execute code. It is
assumed that foreign function teardown will honor that.</p>
<h3 id='define-<name>-<type>'>define <name> <type></h3>
<p>This makes <code>&lt;name&gt;</code> available with the type provided. The type is allowed to
directly access package classes and builtin classes as if you were writing the
definition in Lily. </p>
<p>If the definition is part of a class, it is automatically assumed to be public.
If that is not wanted, then <code>protected</code> or <code>private</code> can be added before
<code>define</code>. The tool will also automatically insert <code>self</code> as the first argument
to a method. The <code>static</code> qualifier will instruct the tool to not do that.</p>
<p>Although a <code>define</code> type may mention optional arguments, be aware that the
interpreter will not implement them. Instead, it is the responsibility of the
definition implemenation to implement optional arguments. Here's an example of
how to do so:</p>
<pre><code>/**
define add(a: Integer, b: *Integer=10): Integer

Add two numbers together, or use '10' if the second number isn't given.
*/
void lily_math__add(lily_state *s)
{
    int left = lily_arg_integer(s, 0);
    int right;

    if (lily_arg_count(s) == 2)
        right = lily_arg_integer(s, 1);
    else
        right = 10;

    lily_return_integer(s, left + right);
}
</code></pre>

<h3 id='var-<name>-':'-<type>'>var <name> ':' <type></h3>
<p>This makes <code>&lt;name&gt;</code> available to the interpreter. Var loading is done by having
a var loading function push a value onto the interpreter. Var loaders must begin
with <code>load_var_</code> as a prefix. A var loader can push a value as simple or as
complex as they wish. A var loader should never have side-effects such as
executing code or relying on global data. Here's an example that exports
apache's request method as <code>server.http_method</code>.</p>
<pre><code>/**
var http_method: String

This is the method that was used to make the request to the server.
Common values are &quot;GET&quot;, and &quot;POST&quot;.
*/
static void load_var_http_method(lily_state *s)
{
    request_rec *r = (request_rec *)lily_config_get(s)-&gt;data;

    lily_push_string(s, r-&gt;method);
}
</code></pre>
        </div>
    </div>
</div>
        <script src="js/jquery.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
        <script src="js/docs.min.js"></script>
    </body>
</html>
